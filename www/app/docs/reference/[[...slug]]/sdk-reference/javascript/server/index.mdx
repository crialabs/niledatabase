import rehypeHighlight from "rehype-highlight";
export const metadata = {
  title: ["Server SDK", "Javascript"],
  description: "Javascript Server SDK reference",
  order: 1,
  tags: ["javascript", "tenant aware", "@niledatabase/server"],
};

# @niledatabase/server

## Installation and configuration

Install the SDK:

  <CodeGroups>
```node
npm install @niledatabase/server
```

```yarn
yarn install @niledatabase/server
```

</CodeGroups>

Set an .env file with database credentials

```bash
NILEDB_USER=
NILEDB_PASSWORD=
```

Then import the SDK:

```javascript
import Nile from "@niledatabase/server";
const nile = await Nile();
```

This creates an instance of Nile Server, which allows you to interact with Nile APIs and DB.

## Configuration

If you would like to pass a configuration manually, that can be done by passing the config to `Nile`. Configs passed in this way take precedence over `.env` vars.

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Type</th>
      <th>.env var</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>user</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_USER</td>
      <td>Required. Username for database authentication.</td>
    </tr>
    <tr>
      <td>password</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_PASSWORD</td>
      <td>Required. Password for database authentication.</td>
    </tr>
    <tr>
      <td>databaseId</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_ID</td>
      <td>ID of the database.</td>
    </tr>
    <tr>
      <td>databaseName</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_NAME</td>
      <td>Name of the database.</td>
    </tr>
    <tr>
      <td>tenantId</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_TENANT</td>
      <td>ID of the tenant associated.</td>
    </tr>
    <tr>
      <td>userId</td>
      <td>
        <pre>string</pre>
      </td>
      <td></td>
      <td>ID of the user associated.</td>
    </tr>
    <tr>
      <td>db</td>
      <td>
        <pre>PoolConfig</pre>
      </td>
      <td></td>
      <td>
        Configuration object for [pg.Pool](https://node-postgres.com/apis/pool).
      </td>
    </tr>
    <tr>
      <td>api</td>
      <td>
        <pre>object</pre>
      </td>
      <td></td>
      <td>Configuration object for API settings.</td>
    </tr>
    <tr>
      <td>api.basePath</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_API</td>
      <td>
        Base host for API for a specific region. Default is{" "}
        <code>api.thenile.dev</code>.
      </td>
    </tr>
    <tr>
      <td>api.cookieKey</td>
      <td>
        <pre>string</pre>
      </td>
      <td></td>
      <td>
        Key for API cookie. Default is <code>token</code>.
      </td>
    </tr>
    <tr>
      <td>api.token</td>
      <td>
        <pre>string</pre>
      </td>
      <td>NILEDB_TOKEN</td>
      <td>Token for API authentication. Mostly for debugging.</td>
    </tr>
    <tr>
      <td>debug</td>
      <td>
        <pre>boolean</pre>
      </td>
      <td></td>
      <td>Flag for enabling debug logging.</td>
    </tr>
  </tbody>
</table>

## Virtual Tenant Databases

In order to connect to Nile's virtual tenant databases and enjoy the full isolation and security, you need to get a reference to tenant-specific instance of Nile Server. This function will either create a new client connection based on the config, or return the existing instance if it has already been registered.

```typescript
nile.getInstance({
  tenantId: tenantId,
  userId: userId,
  api: {
    token: token,
  },
});
```

`userId` and `token` are usually obtained from a cookie that is set during authentication. `tenantId` is the id of the tenant you want to connect to,
and can be set and obtained in the path parameters, query parameters, or headers of the request. In our examples, we use path parameters for the tenant id.
Handling of both cookies and path parameters is framework-specific.

<CodeGroups>
    ```nextjs
    import { cookies } from 'next/headers';

    export default async function Page({ params }: { params: { tenantid: string } }) {

      // First, initialize global Nile instance if needed
      const nile = await Nile()
      const nextCookies = cookies();
      const user = await nile.api.users.me(new Headers({ cookie: nextCookies.toString() }));

      return nile.getInstance({
        tenantId: String(tenantId),
        userId: user?.id,
        api: {
          token: nextCookies.get("nile.session-token")?.value,
        },
      });
    }
    ```

     ```express
    import Nile from "@niledatabase/server";
    import cookieParser from "cookie-parser";

    // First, initialize global Nile instance if needed
    const nile = await Nile();

    app.use(cookieParser());

    app.use('/api/tenants', (req, res, next) => {
        const token = req.cookies["nile.session-token"];
        const user = await nile.api.users.me(new Headers({cookie: req.cookies}));
        nile.userId = user.id,
        nile.token = token,
        next();
    });

    // set the tenant ID in the context based on the URL parameter - this runs after the auth middleware
    app.param('tenantId', (req, res, next, tenantId) => {
        nile.tenantId = tenantId;
        next();
    });
    ```

</CodeGroups>

When you work with tenant-specific references, you can use the same APIs as with the global instance, but they will be scoped to the tenant and user you specified.
Behind the scenes, the Nile SDK manages the connections to the tenant-specific database, and the authentication to the API.

You can leave `tenantId`, `userId` or `token` as `undefined` - in that case, the SDK will use the default configuration.
In our examples, after a user logs in and before they pick a tenant, we set the `userId` and `token`, but leave `tenantId` as `undefined`.
This lets us call the `createTenant` API as the authenticated user.

```javascript
nile.getInstance({
  tenantId: undefined,
  userId: user.id,
  api: {
    token: parsedCookies["nile.session-token"],
  },
});
```

## APIs

@niledatabase/server comes with a set of handlers for authentication, user, and tenant management. These are a thin wrapper around the [regional api](../../../api-reference) that abstract away the database details in order to streamline creating your applications.

### Using handlers (NextJS)

<CodeGroups titles={['api/[...nile]/nile.ts', 'api/[...nile]/route.ts']}>
```javascript
import NileServer from "@niledatabase/server";
const nile = await NileServer();

export const { handlers } = nile.api;
```

```typescript
import { handlers } from "./nile";

export const { POST, GET, DELETE, PUT } = handlers;
```

</CodeGroups>

Lets say you want to customize the route:

<CodeGroups titles={['api/nile/[...nile]/nile.ts', 'api/nile/[...nile]/route.ts']}>
```typescript
import NileServer from "@niledatabase/server";
const nile = await NileServer({ routePrefix: '/api/nile' });

export const { handlers } = nile.api;
```

```typescript
import { handlers } from "./nile";

export const { POST, GET, DELETE, PUT } = handlers;
```

</CodeGroups>
ðŸ’¡ Note: Changing the routes also requires updating `@niledatabase/react` (if you are using that) with a custom `@niledatabase/browser`, which is done via 
```javascript
import Browser from '@niledatabase/browser';
import { NileProvider } from '@niledatabase/react';

export default function App() {
  return (
    <NileProvider
      api={new Browser({ basePath: `${process.env.APP_HOST}/api/nile` })}
    >
      {/*...*/}
    </NileProvider>
  );
}

````

Internally, `@niledatabase/server` will look at the incoming requests
and respond if they match against paths to handle.

#### Custom routes

You can modify route matchers to align more with your application via the `routes` object in the config.

```javascript
const nile = await Nile({
  routes: {
    SIGNIN,
    SESSION
    PROVIDERS,
    CSRF,
    CALLBACK,
    SIGNOUT,
    ME,
    ERROR,
    TENANTS,
    TENANT_USERS,
    USERS,
  }
});
````

Not all available REST endpoints are captured in `@niledatabase/server` is designed to work with user context in mind. You can find the exhaustive list of regional endpoints by visiting [the API reference](../../../api-reference).

### User authentication

#### `GET` /api/auth/signin

Displays a built-in/unbranded sign-in page.

#### `POST` /api/auth/signin/:provider

Starts a provider-specific sign-in flow.

The POST submission requires CSRF token from `/api/auth/csrf`.

In case of an OAuth provider, calling this endpoint will initiate the authorization request to an identity provider, provided they are configured on the dashboard.

#### `GET` /api/auth/providers

Returns a list of configured OAuth services and details (e.g. sign in and callback URLs) for each service, configured by your database from https://console.thenile.dev
This is used internally to ensure that your users can actually sign in based on the configured database.

#### `GET` /api/auth/session

Returns client-safe session object - or an empty object if there is no session.

The contents of the session object that is returned are configurable with the session callback.

#### `GET` /api/auth/csrf

Returns object containing CSRF token. CSRF protection is present on all authentication routes. It uses the "double submit cookie method", which uses a signed HttpOnly, host-only cookie.

#### `GET/POST` /api/auth/callback/:provider

Handles returning requests from OAuth services and username/password during sign-in.

For OAuth 2.0 providers that support the checks: ["state"] option, the state parameter is checked against the one that was generated when the sign in flow was started - this uses a hash of the CSRF token which MUST match for both the POST and GET calls during sign-in.

#### `POST` /api/auth/signout

Handles signing the user out - this is a POST submission to prevent malicious links from triggering signing a user out without their consent.

The user session will be removed from the database for every provider other than basic credentials. For the credentials provider, the JWT will be invalidated.

### Users and tenants

ðŸ’¡ Note: All of these endpoints are executed with the user's context in mind. If you need more flexibility (such as listing all possible tenants in a database), you would need to create your own endpoints.

#### `GET` /api/me

Obtains information about the principal associated with the session.

#### `GET/POST` /api/users

`GET` will list users in a provided tenant. This is done via the headers as `niledb-tenant-id` or as a query param `?tenantId=123-32143-234-234`. `@niledatabase/react` automatically handles `niledb-tenant-id` in most cases.
`POST` will create a new user. A user can be automatically assigned to a tenant, or a new one can be created on their behalf. If a tenant is created, the user is associated to that tenant.

#### `GET/POST` /api/tenants

`GET` will return a list of user's tenants.
`POST` will create a new tenant, then assign the user to the created tenant.

#### `GET/POST/DELETE` /api/tenants/:tenantId

`GET` will return information about a specific tenant, if the user is in the tenant, or will 404 if they are not.
`PUT` updates a tenant, if the user is in the tenant.
`DELETE` sets the deleted column for the tenant, provided the user is in the tenant.

#### `GET/PUT/POST` /api/tenants/:tenantId/users

`GET` obtains a list of users for that tenant, provided the session user is in the tenant
`PUT` associates (links) a user with that tenant, as long as the session user is in the tenant, and the user exists.
`POST` creates a brand new user for that tenant. This is different than `PUT`, as `PUT` takes an existing user (possibly part of other tenants) and gives them access to the session user's tenant.

#### `DELETE` /api/tenants/:tenantId/users/:userId

`DELETE` removes (unlinks) a user from a given tenant. This does not delete a user, as they could be part of other tenants. Their auth session is still valid, but they will not be able to access that specific tenant any more.

### Error handling

When Nile returns an error response (40X or 500), the response will be the raw fetched response, not JSON. Therefore, you need to either check if the value returned from the function call is a response, and then handle the failure accordingly (40x, 500, etc).

Most APIs will respond with `401 Unauthorized` if `nile.session-token` is unset, invalid, not signed by Nile, or expired.

An example of handling errors can be something like this. We use `create tenant` as an example, but this applies to all APIs:

```javascript
try {
    const tenant = await nile.api.tenants.createTenant(name);
    if (tenant instanceof Response) {
      return res.status(createTenantResponse.status).json({
        message: await createTenantResponse.text(),
      });
    }
    res.json(tenant);
  } catch (error: any) {
    console.log("error creating tenant: " + error.message);
    res.status(500).json({
      message: "Internal Server Error",
    });
}
```

In addition to the default routes to handle browser traffic, the SDK also provides a list of methods for server side requests. These are basically the same thing as the REST based routes, they are just wrapped up for ease of use. In most cases, it is possible to simply send the raw `Request` object into the function directly from your HTTP server.

Similar to the REST endpoints, all of these functions execute within the context of a user. For example, `getTenant(id)` will only return that tenant if the user is a member of that tenant.

Each of the requests will attempt to parse the response as JSON. If that fails, a `Response` object will be returned.

ðŸ’¡ Note: Since almost all endpoints are authorization based, `nile.api.headers` is added as a convenience to ensure the correct headers are sent for every request. You can also pass headers to a function. In the future, additional, framework specific packages will handle this automatically.

### Create Tenant

You call `createTenant` with the name of the tenant you want to create.
This will create a tenant, and the current user will be a member of that tenant.

```javascript
const tenant = await nile.api.tenants.createTenant(name);
res.json(tenant);
```

### Get Tenant

This API call doesn't need any input parameters because it uses the tenant ID from the context and returns the current tenant.

```javascript
nile.tenantId = "123";
// additional code
const tenant = await nile.api.tenants.getTenant();
res.json(tenant);
```

### User login

These requests and responses are handled automatically when using `@niledatabase/server` and `@niledatabase/react`, but it is possible to sign in as a user server side, though most scenarios, this should not be necessary, as `/api/auth/signin/:provider` should be called directly from the browser, via `signIn()` imported from `@niledatabase/react`.

```javascript
app.post("/api/login", async (req, res) => {
  const headers = await nile.api.auth.login({
    email: req.body.email,
    password: req.body.password,
  });
  // pass the token along to the browser
  res.set("nile.session-token", headers.get("nile-session-token"));
});
```

### Custom sign up

Lets say you want to customize the signup flow. By default, `@niledatabase/server` responds to `/api/users`. For whatever reason, that URL isn't to your liking, your you would like to do some processing on the data prior to sign up.

To customize signing up a user, you create `/api/sign-up` with the email and password of the user you want to create.

After the the user create succeeds, You can then log in (server side) for this user. We then must set a token in a cookie and include it in the response to the browser:

```javascript
app.post("/api/sign-up", async (req, res) => {
  const creds = {
    email: req.body.email,
    password: req.body.password,
  };

  const resp = await nile.api.users.createUser({
    ...creds,
    preferredName: req.body.preferredName, // optional
  });

  // insert some data for the new user via nile.db.query()

  const headers = await nile.api.login(creds); //handles CSRF, provider fetching, cookies
  res.set("nile.session-token", token);
  res.status(201).json(resp);
});
```

Note that we are returning a response to the browser and expect it to redirect to the correct post-login page, based on whether login succeeds or fails.

## Query Builder

Nile SDK includes a query builder and a connection pool that were designed to work with the Nile's virtual tenant databases with minimal overhead.
You can use Nile with any ORM or database client that you prefer, but using the query builder will give you the best developer experience.

The query builder is built on top of [pg-node](https://node-postgres.com/), so the documentation for pg-node applies to Nile's query builder as well.

### Connecting to the database

When you initialize the Nile Server object, you can pass any valid pg-node pool configuration object as the `db` parameter.
One special case is the `afterCreate` method, which will configure the context of the pool connections for a specific `tenantId` and `userId` if they are provided.

For example:

```javascript
import Nile from "@niledatabase/server";
export const nile = await Nile({
  user: process.env.NILEDB_USER,
  password: process.env.NILEDB_PASSWORD,
});
```

Because Nile manages the connection pool, we recommend not overriding the `pool` settings unless you are sure you know what you are doing.

### Querying the database

The query builder is available as `nile.db`. You can use it to query the database directly, or to build a model layer on top of it. It works exactly like pg-node.

For example, to get all tenants that the current user is a member of:

```javascript
// similar to nile.api.users.listTenants(), but without automatic authorization
const tenants = await nile.db.query(
  `SELECT 
  id, name 
  FROM 
  tenants JOIN users.tenant_users ON tenants.id = tenant_users.id 
  WHERE tenant_users.id = $1`,
  [nile.userId]
);
```

In order to query a virtual tenant database, you need to use a reference that you obtained from `nile.getInstance` with the current `tenantId`, `userId` and `token`.

For example, the following query will all rows in `todos` table for the current tenant:

```javascript
const todos = await nile.db.query("SELECT * from todos ORDER BY title");
```

This also applies to inserts, updates and deletes. For example, to update a todo:

```javascript
const { id, complete } = req.body;
await nile.db.query("UPDATE todos SET complete = $1 WHERE id = $2", [
  complete,
  id,
]);
```

and to create a new one:

```javascript
const { title, complete } = req.body;
const newTodo = await nile.query(
  `INSERT INTO todos (title, complete, tenant_id) 
  VALUES ($1, $2, $3) 
  RETURNING *`,
  [title, Boolean(complete), nile.tenantId]
);
```
